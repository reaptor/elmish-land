module ElmishLand.Init

open System
open System.IO
open System.Reflection
open System.Threading
open Orsak
open ElmishLand.Base
open ElmishLand.TemplateEngine
open ElmishLand.Log
open ElmishLand.DotNetCli
open ElmishLand.Process
open ElmishLand.AppError
open ElmishLand.FsProj
open ElmishLand.Resource

let getNodeVersion () =
    runProcess (FilePath.fromString Environment.CurrentDirectory) "node" [| "-v" |] CancellationToken.None ignore
    |> Effect.changeError (fun _ -> AppError.NodeNotFound)
    |> Effect.map (fun output ->
        match Version.TryParse(output[1..]) with
        | true, version when version >= minimumRequiredNode -> Ok version
        | _ -> Error NodeNotFound)
    |> Effect.joinResult

let successMessage projectDir =
    let projectName = projectDir |> ProjectName.fromProjectDir

    $"""%s{getCommandHeader $"created a new project in ./%s{ProjectName.asString projectName}"}
Run the following command to start the development server:

dotnet elmish-land server
"""

let init (projectDir: AbsoluteProjectDir) =
    eff {
        let! log = Log().Get()

        let projectName = projectDir |> ProjectName.fromProjectDir

        let! dotnetSdkVersion = getLatestDotnetSdkVersion ()
        log.Debug("Using .NET SDK: {}", dotnetSdkVersion)

        let! nodeVersion = getNodeVersion ()
        log.Debug("Using Node.js: {}", nodeVersion)

        log.Debug("Initializing project. {}", AbsoluteProjectDir.asString projectDir)

        let assembly = Assembly.GetExecutingAssembly()

        log.Debug("Resources in assembly:")

        for resource in assembly.GetManifestResourceNames() do
            log.Debug(resource)

        let writeResource = writeResource projectDir false

        let fsProjPath = FsProjPath.fromProjectDir projectDir
        log.Debug("Project path {}", fsProjPath)

        let fsProjExists = File.Exists(FsProjPath.asString fsProjPath)

        do!
            writeResource
                "elmish-land.json.handlebars"
                [ "elmish-land.json" ]
                (Some(
                    handlebars {|
                        ProjectName = ProjectName.asString projectName
                    |}
                ))

        do! writeResource "vite.config.js" [ ".elmish-land"; "vite.config.js" ] None

        do!
            writeResource
                "Base.fsproj.handlebars"
                [ ".elmish-land"; "Base.fsproj" ]
                (Some(
                    handlebars {|
                        DotNetVersion = (DotnetSdkVersion.asFrameworkVersion dotnetSdkVersion)
                    |}
                ))

        do!
            writeResource
                "Project.fsproj.handlebars"
                [ $"%s{ProjectName.asString projectName}.fsproj" ]
                (Some(
                    handlebars {|
                        DotNetVersion = (DotnetSdkVersion.asFrameworkVersion dotnetSdkVersion)
                    |}
                ))

        do!
            writeResource
                "App.fsproj.handlebars"
                [ ".elmish-land/App.fsproj" ]
                (Some(
                    handlebars {|
                        DotNetVersion = (DotnetSdkVersion.asFrameworkVersion dotnetSdkVersion)
                        ProjectReference =
                            $"""<ProjectReference Include="../%s{ProjectName.asString projectName}.fsproj" />"""
                    |}
                ))

        do!
            writeResource
                "global.json.handlebars"
                [ "global.json" ]
                (Some(
                    handlebars {|
                        DotNetSdkVersion = (DotnetSdkVersion.asString dotnetSdkVersion)
                    |}
                ))

        do!
            writeResource
                "package.json.handlebars"
                [ ".elmish-land/package.json" ]
                (Some(
                    handlebars {|
                        ProjectName = projectName |> ProjectName.asString |> String.asKebabCase
                    |}
                ))

        do! writeResource "settings.json" [ ".vscode"; "settings.json" ] None

        let rootModuleName = projectName |> ProjectName.asString |> quoteIfNeeded

        let! routeData =
            if fsProjExists then
                eff { return getRouteData projectDir }
            else
                let homeRoute = {
                    Name = "Home"
                    MsgName = "HomeMsg"
                    ModuleName = $"%s{rootModuleName}.Pages.Home.Page"
                    ArgsDefinition = ""
                    ArgsUsage = ""
                    ArgsPattern = ""
                    Url = "/"
                    UrlPattern = "[]"
                    UrlPatternWithQuery = "[]"
                }

                let routeData = {
                    Autogenerated = getAutogenerated ()
                    RootModule = rootModuleName
                    Routes = [| homeRoute |]
                }

                eff {
                    do!
                        writeResource
                            "Page.handlebars"
                            [ "src"; "Pages"; "Home"; "Page.fs" ]
                            (Some(
                                handlebars {|
                                    RootModule = rootModuleName
                                    Route = homeRoute
                                |}
                            ))

                    return routeData
                }

        log.Debug("Using route data {}", routeData)

        do! writeResource "Shared.handlebars" [ "src"; "Shared.fs" ] (Some(handlebars routeData))

        do! generateRoutesAndApp projectDir routeData

        do! validate projectDir

        do!
            [
                if not (FilePath.exists projectDir [ ".config"; "dotnet-tools.json" ]) then
                    "dotnet", [| "new"; "tool-manifest"; "--force" |]
                for name, version in getDotnetToolDependencies () do
                    "dotnet", [| "tool"; "install"; name; version |]
            ]
            |> List.map (fun (cmd, args) ->
                AbsoluteProjectDir.asFilePath projectDir, cmd, args, CancellationToken.None, ignore)
            |> runProcesses

        do!
            dependencyCommands
            |> List.map (fun (cmd, args) ->
                AbsoluteProjectDir.asFilePath projectDir
                |> FilePath.appendParts [ ".elmish-land" ],
                cmd,
                args,
                CancellationToken.None,
                ignore)
            |> runProcesses


        log.Info(successMessage projectDir)
    }
